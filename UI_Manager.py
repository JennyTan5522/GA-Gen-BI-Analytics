# Standard Libraries
import os
import json
from typing import Optional

# Core Libraries
import streamlit as st
from streamlit_feedback import streamlit_feedback
from pydantic import BaseModel, Field

# Analysis Libraries
import pandas as pd
import numpy as np
from scipy.stats import gaussian_kde
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# LangChain Core and Community Modules
from langchain.memory import ConversationBufferWindowMemory
from langchain.schema.document import Document
from langchain_core.prompts import PromptTemplate, ChatPromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from langchain.retrievers import EnsembleRetriever
from langchain.agents import create_react_agent, AgentExecutor
from langchain_core.tools import tool
from langchain_core.messages import HumanMessage, AIMessage
from langchain_community.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain_anthropic import ChatAnthropic
from tools.output_validator_tool import FinalAnswerValidatorTool

# Custom Modules
from const import (
    WARNING_MESSAGE,
    TEXT_TO_SQL_TO_CHART_PROMPT_TEMPLATE,
    PYTHON_PLOT_PROMPT_TEMPLATE
)
from utils.agent_response_parser import CustomResponseParser
from tools.follow_up_question_tool import FollowUpQuestionTool

class FinalAnswerFormat(BaseModel):
    SQL: str  = Field("SQL Query", description = "The SQL query generated by the LLM")
    TextResponse: str = Field("Text Response", description = "The text response generated by the LLM")
    Code: str = Field("Code Block", description = "The python code block generated by the LLM")

class UIManager:
    def __init__(self, app):
        self.app = app
        self.custom_parser = CustomResponseParser()

    def configure_streamlit(self):
        st.set_page_config(page_title = "GenBI", page_icon = "ðŸ“Š", layout = "wide")

    def configure_session_state(self):
        """
        Initializes default values in Streamlit session state if not already set.
        """
        defaults = {
            "k": 5,
            "memory": ConversationBufferWindowMemory(
                memory_key = 'chat_history',
                k = 5,
                return_messages = True,
            ),
            "tables_info": {}
        }
        for key, value in defaults.items():
            if key not in st.session_state:
                st.session_state[key] = value

    def configure_sidebar(self):
        """
        Configures the Streamlit sidebar with options for data connection, API key setup, and clearing message history.
        """
        with st.sidebar:
            st.markdown("## âš™ Settings")
            st.write("Configure your settings below.")
            
            # Data Connection
            with st.expander("Connect to Data", expanded=True):
                connection_type = st.selectbox("Choose connection type", ("Upload CSV/Excel", "Connect to Database"))

                if connection_type == "Upload CSV/Excel":
                    data = st.file_uploader("\U0001F4BB Load an Excel file:", type=["csv", "xlsx"])
                    if data:
                        st.session_state.data = data
                        self.app.data_manager.excel_data_connection()

                elif connection_type == "Connect to Database":
                    self.app.data_manager.handle_database_connection()

            st.markdown("---")

            # Model Connection
            st.title("API Access")
            
            # Input field for Claude API key
            claude_api_key = st.text_input("Enter your Claude API Key:", type="password")

            if st.button("Connect to Claude API"):
                if claude_api_key:
                    try:
                        claude_llm = ChatAnthropic(
                            api_key=claude_api_key,
                            model="claude-3-5-sonnet-20241022",
                            temperature=0
                        )
                        # Test the key is correct or not
                        response = claude_llm([HumanMessage(content="Hello")])
                        st.session_state.llm = claude_llm
                        st.success("âœ… Successfully connected to Claude API.")
                    except Exception as e:
                        st.error(f"âŒ Failed to connect to Claude API: {e}")
                else:
                    st.warning("âš ï¸ Please enter your Claude API key before connecting.")

            # Memory Settings
            st.sidebar.write("ðŸ›  Memory Settings")
            st.session_state.k = st.slider("Memory Size", 1, 10, st.session_state.k)

            # Clear History Button
            if st.button("ðŸ—‘ Clear Message History"):
                if "messages" in st.session_state:
                    st.session_state.messages = []
                if "memory" in st.session_state:
                    st.session_state.memory.clear()  
                st.success("Message history cleared!")

    def display_tabs(self):
        response_tab, data_tab = st.tabs(["ðŸ’¬ Response View", "ðŸ“œ Data Explorer"])
        
        with response_tab:
            self.handle_response_tab()

        with data_tab:
            self.handle_data_tab()

    def get_table_info(self, tables_info: dict):
        all_tables_info = ""
        include_user_define_note = False
        
        for table_name, full_table_info in tables_info.items():
            table_summary = full_table_info.get("table_summary", "")
            df = pd.DataFrame(full_table_info.get("table_columns_info", []))

            # Step 1: Drop fully empty columns BEFORE filtering rows
            df = df.replace(r'^\s*$', np.nan, regex=True)
            filtered_data_df = df.dropna(axis=1, how="all")

            # Step 2: Removes rows where all other columns except 'Dataset Column Name' are NaN.
            filtered_data_df = filtered_data_df[filtered_data_df.drop(columns=['Dataset Column Name']).notna().any(axis=1)]

            # Check if user defined name is provided
            if 'User Define Column Name' in filtered_data_df.columns and \
            filtered_data_df['User Define Column Name'].fillna("").str.strip().any():
                include_user_define_note = True

            # Step 3: Convert to JSON format
            extra_info_json = filtered_data_df.to_json(orient="records", indent=2)

            # Step 4: Organize the info
            all_tables_info += f"Table {table_name}\n"

            if table_summary:
                all_tables_info += f"Summary\n{table_summary}\n\n"

            all_tables_info += f"### Table Context Information\n{extra_info_json}\n"
            all_tables_info += "### End of Context\n\n"

        # Add prefix explanation
        explanation =""
        if include_user_define_note:
            explanation += (
                "- 'Dataset Column Name' refers to the original column name in the dataset.\n"
                "- 'User Define Column Name' is a clearer or more descriptive name provided by the user. "
                "Prefer this name when constructing SQL queries if it exists.\n"
            )
        explanation += (
            "- Use 'Description' for semantic meaning.\n"
            "- Use 'Calculation/Formula' for relevant logic in queries.\n\n"
        )

        return explanation + all_tables_info

    def react_agent_toolkit(self, additional_feedbacks: Optional[str] = None):
        """
        Creates and configures a ReAct agent toolkit with SQL, Python execution, and response validation capabilities.

        This agent is designed to interact with a database, with tools: SQLDatabaseToolkit and FollowUpQuestionTool.

        Args:
            additional_feedbacks: (Optional) Additional feedback or context provided from user to be included in the prompt template.

        Returns:
            AgentExecutor: An agent executor capable of handling complex queries and reasoning through multiple tools.
        """
        st.write("Inside React Agent")
        db_toolkit = SQLDatabaseToolkit(db=st.session_state.db, llm=st.session_state.llm)
        tools = db_toolkit.get_tools()
        tools.extend([
            FollowUpQuestionTool(llm=st.session_state.llm), 
            FinalAnswerValidatorTool(llm=st.session_state.llm)])
        
        st.write("Before Pairing")
        
        # Get the latest k pairs of messages from the chat history
        paired_history_messages = []
        latest_k_chat_history = ""

        try: 
            for i in range(1, len(st.session_state.messages) - 1, 2):
                if st.session_state.messages[i]['role'] == "user" and st.session_state.messages[i+1]['role'] == "assistant":
                    paired_history_messages.append((st.session_state.messages[i]['content'], st.session_state.messages[i + 1]['content']))
                  
        except Exception as e:
            st.error(f"Error while pairing messages: {e}")

        latest_k_pairs = paired_history_messages[-st.session_state.k:]
        st.write("After Pairing")
        
        for idx, (human, ai) in enumerate(latest_k_pairs, 1):
            latest_k_chat_history += f"--- Chat {idx} ---\n"
            latest_k_chat_history += f"User: {human}\n"
            try:
                # Attempt to parse the assistant response as JSON
                content_json = json.loads(ai)
                sql = content_json.get("SQL")
                text_response = content_json.get("TextResponse")
                if sql:
                    latest_k_chat_history += f"Assistant (SQL): {sql}\n\n"
                else:
                    latest_k_chat_history += f"Assistant (TextResponse): {text_response}\n\n"
            except json.JSONDecodeError:
                latest_k_chat_history += f"Assistant: {ai}\n\n"

        st.write("Generate k history")

        # Get the table info
        table_info_prompt_template = ""
        if st.session_state.tables_info and len(st.session_state.tables_info) > 0:
            all_tables_info = self.get_table_info(st.session_state.tables_info)
            table_info_prompt_template += "\nThe following context provides detailed information about the database tables and their columns.\n"
            table_info_prompt_template += "Use this information to accurately generate SQL queries.\n"
            table_info_prompt_template += "## Table Context Information\n"
            table_info_prompt_template += f"\n{all_tables_info}"

        st.write("Generate Table Template")

        prompt_template = PromptTemplate.from_template(
            TEXT_TO_SQL_TO_CHART_PROMPT_TEMPLATE,
            partial_variables={
                "python_plot_instructions": PYTHON_PLOT_PROMPT_TEMPLATE, 
                "db": st.session_state.db, 
                "top_k": 10, 
                "dialect": st.session_state.db.dialect,
                "additional_table_info": table_info_prompt_template,
                "additional_feedbacks": additional_feedbacks,
                "plotly_unique_key": int((len(st.session_state.messages) + 1)/2),
                "chat_history": latest_k_chat_history,
            },
        )

        st.write("Finish Prompt Template")
       
        react_agent = create_react_agent(
            llm = st.session_state.llm, 
            tools = tools, 
            prompt = prompt_template, 
        )

        agent_executor = AgentExecutor(
            agent = react_agent, 
            tools = tools, 
            verbose = True,
            memory = st.session_state.memory,
            handle_parsing_errors = True,
            max_iteration = 50, 
            max_execution_time = 300,
            return_intermediate_steps = True
        )

        return agent_executor
    
    def regenerate_final_answer_prompt(self, regenerate_query_context: str):
        return f"""
            ### Additional User Feedback:
            The user provided feedback on the previous question. This could be:
            - A corrected SQL query provided by the user if the generated one was wrong.
            - An explanation from the user if the original question was flawed or unanswerable. 
            (Note: The user might also provide an invalid or incorrect explanation â€” you must validate it logically based on the question and schema.)

            {regenerate_query_context}
        """
    
    def invoke_agent_response(self, agent_executor: AgentExecutor, user_query: str, user_feedback = False):
        """
        Invokes the agent to (1) generates a response, (2) parse the final answer in pydantic format, (3) display the final answer in UI, (4) saves it to messages.

        Args:
            agent_executor (AgentExecutor): The agent executor configured with tools and prompts.
            user_query (str): The query provided by the user.
            user_feedback (bool, optional): Indicates if the query includes user feedback. Defaults to False.
        Raises:
            ValueError: If there is an issue parsing the agent's response.
            Exception: For any other errors during execution.
        """
        if user_feedback:
            query_input = f"Previous User Question: {user_query}"
            user_message = st.session_state.feedback if st.session_state.feedback != "" else user_query
            saved_user_message = user_message.get("text", user_message) if isinstance(user_message, dict) else user_message
        else:
            query_input = user_message = saved_user_message = user_query

        st.session_state.messages.append({"role": "user", "content": saved_user_message})
        response_text = agent_executor.invoke({"input": query_input})
        cleaned_response_text = response_text['output'].strip().replace('```json', '').replace('```', '')
        
        try:
            output_parser = PydanticOutputParser(pydantic_object=FinalAnswerFormat)
            final_answer_pydantic_format = output_parser.invoke(cleaned_response_text)
          
            sql = final_answer_pydantic_format.SQL
            text_response = final_answer_pydantic_format.TextResponse
            code_block = final_answer_pydantic_format.Code

            self.app.logger.debug(f"Final Answer: \n{final_answer_pydantic_format}")
        except Exception as e:
            self.app.logger.error(f"Pydantic Parsing error: {e}")
            self.app.logger.error(response_text)
            st.error(f"Pydantic Parsing error.")

        final_answer_str_format = json.dumps(final_answer_pydantic_format.dict(), indent=4)
        st.session_state.messages.append({"role": "assistant", "content": final_answer_str_format, "agent_thinking_process": response_text["intermediate_steps"]})
        st.session_state.feedback = None
        return sql, text_response, code_block, response_text["intermediate_steps"]

    def display_feedback_form(self, user_query: str):
        """
        Displays a feedback form for users to provide feedback on the LLM response.

        The feedback form allows users to:
        - Provide a thumbs-up or thumbs-down rating for the response.
        - Optionally include a reason for their feedback or suggest a corrected SQL query if the response was incorrect.

        Args:
            user_query (str): The original query provided by the user, used to regenerate the response if feedback is submitted.
        """
        with st.form("feedback_form"):
            streamlit_feedback(feedback_type="thumbs", optional_text_label="[Optional] Provide reason if the question is wrong, or provide the correct SQL if the answer is incorrect.", align="flex-start", key='feedback')
            st.form_submit_button('Regenerate Response', on_click=lambda: self.handle_user_feedback(user_query)) 

    def handle_user_feedback(self, user_query: str):
        """
        Handles user feedback for the last generated response and regenerates the agent's response based on the feedback.

        This method retrieves the last message from the session's chat memory, extracts the context of the previous 
        response (e.g., SQL query or answer), and combines it with the user's feedback. It then uses this information 
        to regenerate a new response by invoking the agent with the updated context.

        Args:
            user_query (str): The original query provided by the user.
        """
        if not len(st.session_state.memory.chat_memory.messages) > 0:
            return
        
        last_message = st.session_state.memory.chat_memory.messages[-1]
        feedback_response = ""
 
        if hasattr(last_message, "content") and last_message.content:
            try:
                final_answer = json.loads(last_message.content)
                sql_query = final_answer.get("SQL", None)
                text_response = final_answer.get("TextResponse", None)
                feedback_response = (f"\n Previous SQL Query or Previous Answer: {sql_query if sql_query else text_response}")
            except:
                feedback_response = (f"\n Previous SQL Query or Previous Answer: {last_message.content}")

            # TODO: The feedback need to detect is thumbs up or down
            if st.session_state.feedback:
                feedback_response += f"\n Current User Feedback or Request: {st.session_state.feedback}"
            else:
                feedback_response += f"\n Current User Feedback or Request: The previous answer is not satisfactory. Please re-check the user request and provide a better response."

        agent_executor = self.react_agent_toolkit(additional_feedbacks = self.regenerate_final_answer_prompt(feedback_response))
        self.invoke_agent_response(agent_executor, user_query, user_feedback = True)

    def _render_agent_thinking(self, agent_thoughts):
        st.markdown("""
            <style>
            div[data-testid="stExpander"] div[role="button"] p {
                font-size: 1.2rem;
                font-weight: bold;
            }
            pre code {
                white-space: pre-wrap !important;
            }
            </style>
        """, unsafe_allow_html=True)

        for i, step in enumerate(agent_thoughts, 1):
            with st.expander(f"Step {i}: Thinking Process", expanded=False):
                if isinstance(step, tuple) and len(step) >= 2:
                    action, observation = step[0], step[1]
                    st.markdown(f"*Action:* {action.tool}")
                    st.markdown(f"*Input:*\n\n{action.tool_input}\n")
                    st.markdown(f"*Observation:*\n\n{observation}\n")
                else:
                    st.json(step)
                    
    def display_response(self, sql: str, response: str, code_block: str, agent_thoughts: str = None):
        """
        Displays the response from an SQL query or a generated result, optionally rendering a visualization.

        Args:
            sql (str): The SQL query used to generate the response.
            response (str): The textual response generated from the SQL query or retrieval process.
            code_block (str): A Python code block that generates a visualization.
            agent_thoughts (str, optional): Agent's reasoning or steps.
        """
        sql_is_blank = not sql.strip() or "blank" in sql.lower()
        code_is_blank = not code_block.strip() or "blank" in code_block.lower()

        # If both SQL and code are blank, show response only
        try:
            if sql_is_blank and code_is_blank:
                st.markdown(f"Response:\n{response}")
                return
    
            elif not code_is_blank:
                # Compile and show full tabs if code is present
                compiled_code = compile(code_block, '<string>', 'exec')
                chart_tab, sql_tab, code_tab, agent_tab = st.tabs(["ðŸ“Š Chart", "ðŸ›¢ SQL", "ðŸ’» Code", "ðŸ§  Agent Thinking"])

                with chart_tab:
                    local_scope = {}
                    exec(code_block, {}, local_scope)

                with sql_tab:
                    if not sql_is_blank:
                        st.code(sql, language="sql")
                    if response and "blank" not in response.lower():
                        st.markdown(f"Response: \n{response}")

                with code_tab:
                    formatted_code = code_block.replace(";", ";\n").replace("import", "\nimport")
                    st.code(formatted_code, language="python")

                with agent_tab:
                    if agent_thoughts:
                        self._render_agent_thinking(agent_thoughts)
                    else:
                        st.info("No agent reasoning provided.")
            else:
                # If code is blank, show only SQL and Agent tabs
                sql_tab, agent_tab = st.tabs(["ðŸ›¢ SQL", "ðŸ§  Agent Thinking"])

                with sql_tab:
                    if not sql_is_blank:
                        st.code(sql, language="sql")
                    if response and "blank" not in response.lower():
                        st.markdown(f"Response: \n{response}")

                with agent_tab:
                    if agent_thoughts:
                        self._render_agent_thinking(agent_thoughts)
                    else:
                        st.info("No agent reasoning provided.")

        except Exception as e:
            st.error(f"Error while rendering chart or code: {e}")

    def handle_response_tab(self):
        if "db" not in st.session_state:
            st.warning(WARNING_MESSAGE)
            return
        elif "llm" not in st.session_state:
            st.warning("Please enter the API key to start conversation")
            return 

        if "messages" not in st.session_state:
            st.session_state["messages"] = [{"role": "assistant", "content": "Hello! I'm your SQL Assistant. How can I assist you today?"}]
            self.app.logger.debug("Session messages initialized.")
            st.session_state["selected_mode"] = "SQL to Chart ðŸ“Š" 

        if "excel_summary" in st.session_state:
            summary_html = st.session_state.excel_summary.replace("\n", "<br>")

            with st.expander("ðŸ“ƒ Data Summary"):
                st.markdown(f"""<p style="font-size: 11px; color: gray;"> An enriched data summary with semantic types and descriptions.</p>""",unsafe_allow_html=True)
                st.markdown(
                    f"""
                    <div style="font-size: 11px; color: gray; text-align: justify; background-color: #f0f0f0; border-radius: 8px; padding: 10px; ">
                        {summary_html} 
                    </div>
                    """,
                    unsafe_allow_html=True
                )
            
        if "question_recommendations" in st.session_state:
            grouped_questions = {}
            # Organize questions by category
            for item in st.session_state.question_recommendations["questions"]:
                category = item["category"]
                question = item["question"]
                
                if category not in grouped_questions:
                    grouped_questions[category] = []
                grouped_questions[category].append(question)

            with st.expander("ðŸ’¡ Goal Exploration"):
                st.markdown(f"""<p style="font-size: 11px; color: gray;"> A list of automatically generated data exploration goals based on the dataset given.</p>""",unsafe_allow_html=True)
                categories = list(grouped_questions.keys())  
                num_columns = 3 
                columns = st.columns(num_columns)  

                # Iterate over categories and distribute them in columns
                for index, category in enumerate(categories):
                    col = columns[index % num_columns]  
                    with col.container():
                        st.markdown(
                            f"""
                            <div style="border-radius: 8px; padding-left: 10px; background-color: #f9f9f9; 
                                        box-shadow: 2px 2px 5px rgba(0,0,0,0.1); width: 100%;">
                                <h4 style="color: #333; font-size: 13px; font-weight: bold; margin: 0;">{category}</h4>
                            </div>
                            <div style="padding-left: 15px; margin-top: 5px;">
                                <ul style="padding-left: 15px; color: #333;">
                                    {''.join(f'<li style="margin-bottom: 4px; font-size: 11px; text-align: justify;">{question}</li>' for question in grouped_questions[category])}
                                </ul>
                            </div>
                            """,
                            unsafe_allow_html=True
                        )

        # Display chat history
        for message in st.session_state.messages:
            role = message.get("role")
            if role == "user":
                with st.chat_message("user"):
                    content = message["content"]
                    st.write(content)

            if role == "assistant":
                with st.chat_message("assistant"):
                    content = message["content"]
                    try:
                        # Converts the str response to dict format
                        content_json = json.loads(content)
                        self.app.logger.debug(f"Content JSON: {content_json}")
                        self.display_response(content_json['SQL'], content_json['TextResponse'], content_json['Code'], message["agent_thinking_process"])
                    except:
                        st.write(content)

        # Style to fix the chatbot position
        st.markdown(
            """
            <style>
            /* Chat input box */
            .stChatInput {
                position: fixed;
                bottom: 25px; 
                left: 350px; 
                width: calc(100% - 350px);
                background-color: white;
                padding: 10px;
                box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
                z-index: 1000;
                border-radius: 10px;
            }

            /* Disclaimer text */
            .disclaimer {
                position: fixed;
                bottom: 0px; 
                margin-bottom: -5px;
                left: 350px;
                width: calc(100% - 350px);
                font-size: 11px;
                color: gray;
                text-align: center;
                background-color: white;
                padding: 5px 10px;
                z-index: 999; /* Lower z-index to stay below chat input */
            }

            /* Radio button styling */
            .stRadio > div {
                display: flex;
                gap: 10px;
                align-items: center;
                margin-bottom: 10px;
            }
            </style>
            """,
            unsafe_allow_html=True,
        )

        st.markdown(
            """
            <p class="disclaimer">
                <strong> Disclaimer:</strong> Gen BI system may make mistakes; review results and use your judgment. 
            </p>
            """,
            unsafe_allow_html=True,
        )

        user_query = st.chat_input(placeholder="Ask me anything!")

        if user_query:
            st.chat_message("user").write(user_query)
            with st.chat_message("assistant"):
                with st.spinner("We are preparing a response to your question. Please allow up to one minute for completion...."):
                    try:
                        # Invoke the agent response
                        st.write("React Agent")
                        agent_executor = self.react_agent_toolkit()
                        st.write("Invoke React Agent")
                        sql, text_response, code_block, intermediate_steps = self.invoke_agent_response(agent_executor, user_query)
                        self.display_response(sql, text_response, code_block, intermediate_steps)

                        # Show feedback form for user to provide feedback on the response
                        self.display_feedback_form(user_query)
                    except Exception as e:
                        st.warning(f"An error occurred while processing your request. Please try again. {e}")

    def handle_data_tab(self):
        if "db" not in st.session_state:
            st.warning(WARNING_MESSAGE)
            return
        elif "llm" not in st.session_state:
            st.warning("Please enter the API key to start conversation")
            return 
        
        st.write("#### Dataset Table Selection")
        tables = st.session_state.sql_inspector.get_table_names()
        self.app.logger.info(f"Tables in database: {tables}")
        selected_table = st.selectbox("Choose a table from the database for Data Preview:", tables)
        st.session_state.df = pd.read_sql(f'SELECT * FROM "{selected_table}"', st.session_state.db._engine)
        st.session_state.df = st.session_state.df.dropna(axis=1, how="all")
        total_rows = st.session_state.df.shape[0]

        # Default values
        table_summary = ""
        editable_data = None

        # Check if saved file exists
        json_path = f"data/{selected_table}.json"
        if os.path.exists(json_path):
            with open(json_path, "r") as f:
                saved_data = json.load(f)

            if selected_table in saved_data:
                full_table_info = saved_data[selected_table]
                table_summary = full_table_info.get("table_summary", "")
                editable_data = pd.DataFrame(full_table_info.get("table_columns_info", []))

                # Update the table variable
                st.session_state.tables_info[selected_table] = full_table_info
                
        with st.form("table_data"):
            # Allow user to provide a short table summary
            st.write("#### Table Summary")
            st.write("[Optional] Briefly describe what this table is about.")
            table_summary = st.text_area("", placeholder="This table contains sales data for Q1 2025, including product details and revenue.")

            # Create a table with original column names, editable user input column names, descriptions, and formulas
            original_columns = st.session_state.df.columns.tolist()

            # Create a blank editable table only if no data was loaded
            if editable_data is None:
                editable_data = pd.DataFrame({
                    "Dataset Column Name": original_columns,  
                    "User Define Column Name": [""] * len(original_columns), 
                    "Description": [""] * len(original_columns), 
                    "Calculation/Formula": [""] * len(original_columns) 
                })
                
            st.write("#### Table Data")
            st.write("[Optional] Edit the full column names, add descriptions, or define formulas as needed.")
            edited_table_data = st.data_editor(
                editable_data,
                num_rows = "fixed",
                use_container_width=True,
                column_config={
                    "Dataset Column Name": st.column_config.Column(disabled=True, width="fit"), 
                    "User Define Column Name": st.column_config.Column(width="fit"),
                    "Description": st.column_config.Column(width=400),
                    "Calculation/Formula": st.column_config.Column(width=400)
                }
            )

            # Process the edited data
            if st.form_submit_button("Save Changes"):
                # Save all information together
                full_table_info = {
                    "table_name": selected_table,
                    "table_summary": table_summary,
                    "table_columns_info": edited_table_data.to_dict(orient="records")
                }
                st.session_state.tables_info[selected_table] = full_table_info

                # Save as JSON file
                with open(f"data/{selected_table}.json", "w") as f:
                    json.dump(st.session_state.tables_info, f, indent=2)

        st.divider()

        # Step 1: Filter Col
        st.write("#### Data Filter and Preview")
        with st.form("search_form"):
            total_rows = st.session_state.df.shape[0]
            selected_columns = st.multiselect("ðŸ“Œ Select Columns for Display", st.session_state.df.columns.tolist(), default=st.session_state.df.columns.tolist())
            row_col, display_col = st.columns([1, 1])
            with row_col:
                display_rows = st.number_input("ðŸ”¹ Enter the number of rows to display:", placeholder="5", min_value=1, max_value=total_rows, value=min(10, total_rows))
            
            with display_col:
                search_query = st.text_input("ðŸ”¹ Filter dataset by value:", "", placeholder="ðŸ” Enter the filter value you want to search in dataset")
            
            submitted = st.form_submit_button("Search")

            if submitted:
                if search_query:
                    filtered_df = st.session_state.df[selected_columns][st.session_state.df[selected_columns].apply(lambda row: row.astype(str).str.contains(search_query, case=False).any(), axis=1)]
                else:
                    filtered_df = st.session_state.df[selected_columns]
                
                # Reset index to start from 1
                filtered_df.index = pd.RangeIndex(start=1, stop=len(filtered_df) + 1, step=1)
                st.dataframe(filtered_df.head(display_rows))
                st.session_state.df = filtered_df
            else:
                # Reset index before displaying
                preview_df = st.session_state.df[selected_columns]
                preview_df.index = pd.RangeIndex(start=1, stop=len(preview_df) + 1, step=1)

                st.dataframe(preview_df.head(display_rows))
                st.session_state.df = preview_df

            st.write(f"*Total Dataset Rows:* {total_rows}; *Display Rows:* {display_rows}")

        # Export to CSV
        csv = st.session_state.df.to_csv(index=False)
        st.download_button(
            label = "Export to CSV",
            data=csv,
            file_name="exported_data.csv"
        )

        # Step 2: Show table information by using df.info
        buffer = pd.io.common.StringIO()  
        st.session_state.df.info(buf=buffer)
        info_text = buffer.getvalue().split("\n")

        columns = []
        for line in info_text[5:-3]:
            parts = line.split()
            if len(parts) >= 4:
                col_name = parts[1]  # Column name
                non_null_count = parts[-3] + " " + parts[-2]  # Non-null count (e.g., "1000 non-null")
                dtype = parts[-1]  # Data type
                columns.append([col_name, non_null_count, dtype])
        
        df_info = pd.DataFrame(columns, columns=["Feature", "Non-Null Count", "Data Type"])
        df_info["Unique Count"] = df_info["Feature"].apply(lambda col: st.session_state.df[col].nunique(dropna=True))
        df_info["Unique Values"] = df_info["Feature"].apply(
            lambda col: ", ".join(map(str, st.session_state.df[col].dropna().unique()))
            if st.session_state.df[col].nunique(dropna=True) <= 10
            else "The feature has high cardinality; unique values greater than 10 are not displayed."
        )

        def highlight_missing(val):
            count = int(val.split(" ")[0])  # Extract missing count
            color = "green" if count == 0 else "red"
            return f"background-color: {color}; color: white;"
        
        total_rows = len(st.session_state.df)
        df_info["Missing Count"] = df_info["Feature"].apply(
            lambda col: f"{st.session_state.df[col].isna().sum()} ({(st.session_state.df[col].isna().sum() / total_rows * 100):.2f}%)"
        )

        # Step 3: Show Data Shape
        st.divider()
        st.write("#### Data Shape")
        st.write(f"Number of Rows: {st.session_state.df.shape[0]}, Number of Columns: {st.session_state.df.shape[1]}")

        # Step 4: Data Overview
        st.divider()
        st.write("#### Data Overview")
        df_info.index = pd.RangeIndex(start=1, stop=len(df_info) + 1, step=1)  
        st.dataframe(df_info.style.applymap(highlight_missing, subset=["Missing Count"]))
        st.markdown(f"There are *{st.session_state.df.duplicated().sum()}* duplicated row(s) in this {selected_table} table.")
        
        # Step 5: Data Description
        st.divider()
        st.write("#### Data Description")
        st.write(st.session_state.df.describe())